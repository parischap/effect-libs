/* eslint-disable functional/no-expression-statements */
import { ASStyle, ASText } from '@parischap/ansi-styles';
import { MUtils } from '@parischap/effect-lib';
import {
	PPNonPrimitiveFormatter,
	PPOption,
	PPStringifiedValue,
	PPValue,
	PPValueFormatter
} from '@parischap/pretty-print';
import { Array, Equal, Function, pipe } from 'effect';
import { describe, expect, it } from 'vitest';

describe('ValueFormatter', () => {
	const utilInspectLike = PPOption.darkModeUtilInspectLike;
	const valueBasedFormatterConstructor =
		PPValueBasedFormatterConstructor.fromOption(utilInspectLike);
	const markShowerConstructor = PPOption.MarkShowerConstructor.fromOption(utilInspectLike);
	const nonPrimitiveOption = PPOption.NonPrimitive.maps('Foo');
	const constructors = {
		valueBasedFormatterConstructor,
		markShowerConstructor
	};
	const valueOnly = PPValueFormatter.valueOnly;

	const stringified = pipe('1', ASText.fromString, PPStringifiedValue.fromText);

	describe('Tag, prototype and guards', () => {
		it('moduleTag', () => {
			expect(PPValueFormatter.moduleTag).toBe(MUtils.moduleTagFromFileName(__filename));
		});

		describe('Equal.equals', () => {
			const dummy = PPValueFormatter.make({
				id: 'ValueOnly',
				action: () => () => () => PPStringifiedValue.empty
			});
			it('Matching', () => {
				expect(Equal.equals(valueOnly, dummy)).toBe(true);
			});

			it('Non-matching', () => {
				expect(Equal.equals(valueOnly, PPValueFormatter.keyAndValue)).toBe(false);
			});
		});

		it('.toString()', () => {
			expect(valueOnly.toString()).toBe(`ValueOnly`);
		});

		it('.pipe()', () => {
			expect(valueOnly.pipe(PPValueFormatter.id)).toBe('ValueOnly');
		});

		describe('has', () => {
			it('Matching', () => {
				expect(PPValueFormatter.has(valueOnly)).toBe(true);
			});
			it('Non matching', () => {
				expect(PPValueFormatter.has(new Date())).toBe(false);
			});
		});
	});

	it('valueOnly', () => {
		expect(
			pipe(
				PPValue.fromNonPrimitiveValueAndKey({
					nonPrimitiveContent: { a: 1, b: 'foo' },
					key: 'a',
					depth: 1,
					protoDepth: 0
				}),
				PPValueFormatter.valueOnly.call(nonPrimitiveOption, constructors),
				Function.apply(stringified),
				PPStringifiedValue.toAnsiString()
			)
		).toBe(pipe('1', ASStyle.none, PPStringifiedValue.fromText, PPStringifiedValue.toAnsiString()));
	});

	describe('keyAndValue', () => {
		it('With empty key', () => {
			expect(
				pipe(
					PPValue.fromTopValue(1),
					PPValueFormatter.keyAndValue.call(nonPrimitiveOption, constructors),
					Function.apply(stringified),
					PPStringifiedValue.toAnsiString()
				)
			).toBe(
				pipe('1', ASStyle.none, PPStringifiedValue.fromText, PPStringifiedValue.toAnsiString())
			);
		});

		it('With one-line key at protoDepth=0', () => {
			expect(
				pipe(
					PPValue.fromNonPrimitiveValueAndKey({
						nonPrimitiveContent: { a: 1, b: 'foo' },
						key: 'a',
						depth: 1,
						protoDepth: 0
					}),
					PPValueFormatter.keyAndValue.call(nonPrimitiveOption, constructors),
					Function.apply(stringified),
					PPStringifiedValue.toAnsiString()
				)
			).toBe(
				pipe(
					ASStyle.none(ASStyle.red('a'), ASStyle.white(' => '), '1'),
					PPStringifiedValue.fromText,
					PPStringifiedValue.toAnsiString()
				)
			);
		});

		it('With one-line key at protoDepth=2', () => {
			expect(
				pipe(
					PPValue.fromNonPrimitiveValueAndKey({
						nonPrimitiveContent: { a: 1, b: 'foo' },
						key: 'a',
						depth: 1,
						protoDepth: 2
					}),
					PPValueFormatter.keyAndValue.call(nonPrimitiveOption, constructors),
					Function.apply(stringified),
					PPStringifiedValue.toAnsiString()
				)
			).toBe(
				pipe(
					ASStyle.none(ASStyle.red('a'), ASStyle.green('@@'), ASStyle.white(' => '), '1'),
					PPStringifiedValue.fromText,
					PPStringifiedValue.toAnsiString()
				)
			);
		});

		it('With multi-line key and multiline value', () => {
			expect(
				pipe(
					PPValue.fromIterable({
						content: { c: 3, d: 4 },
						stringKey: ['{', '  c : 3,', '  d : 4', '}'],
						autogeneratedKey: false,
						depth: 1
					}),
					PPValueFormatter.keyAndValue.call(
						PPOption.NonPrimitive.make({
							...nonPrimitiveOption,
							nonPrimitiveFormatter: PPNonPrimitiveFormatter.tabify
						}),
						constructors
					),
					Function.apply(
						Array.make(
							ASText.fromString('{'),
							ASText.fromString('  a : 1,'),
							ASText.fromString('  b : 2'),
							ASText.fromString('}')
						)
					),
					PPStringifiedValue.toAnsiString()
				)
			).toBe(
				pipe(
					Array.make(
						ASStyle.red('{'),
						ASStyle.red('  c : 3,'),
						ASStyle.red('  d : 4'),
						ASStyle.none(ASStyle.red('}'), ASStyle.white(' => '), '{'),
						ASStyle.none('  a : 1,'),
						ASStyle.none('  b : 2'),
						ASStyle.none('}')
					),
					PPStringifiedValue.toAnsiString()
				)
			);
		});
	});
});
